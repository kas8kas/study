# 포인터
***
```c++
  int* ptr1 = nullptr;     // 포인터 변수 선언
  int a = 0;               // 정수형 변수를 선언하고 10 저장
  ptr = &a;                // a의 메모리 주소를 포인터 변수 ptr에 저장
  *ptr = 1;                // 역참조 연산자로 메모리 주소에 접근하여 20을 저장
  cout << a << endl;       // 결과: 1
```
- 포인터는 주소값을 담는 변수
- 역참조 연산자 \* 로 주소에 접근하여 값을 가져옵니다.
- 참조연산자 & 로 주소값을 반환합니다.
***
### 포인터의 크기
```c++
  int* ptr1 = nullptr;
	cout << sizeof(ptr1) << endl;  // 결과: 4
  
  short* ptr2 = nullptr;
	cout << sizeof(ptr2) << endl; // 결과: 4

	double* ptr3 = nullptr;
	cout << sizeof(ptr3) << endl; // 결과: 4
```
- 포인터 변수는 주소값을 담는 변수로, 32비트 환경에서는 4바이트의 크기를 가진다.
- 포인터 앞 자료형은 주소값의 담기는 자료형을 뜻한다.
***
### const 포인터
```c++
	int a = 0;

	//역참조 변경 불가
	const int* ptr1 = nullptr;
	ptr1 = &a;	//가능
	*ptr1 = 10;	//불가

	//역참조 변경 불가 -> ptr1과 동일
	int const*  ptr2 = nullptr;
	ptr2 = &a;
	*ptr2 = 10;

	//주소값 변경 불가
	int* const ptr3 = nullptr;
	ptr3 = &a;	//불가
	*ptr3 = 10;	//가능


	//역참조, 주소값 변경 불가
	const int* const ptr4 = nullptr;
	ptr4 = &a; //불가
	*ptr4 = 10; //불가
```
***
### 배열
```c++
	int arr[3] = { 1,2,3 };
	int* ptr = arr;

	cout << sizeof(arr[0]) << endl;	//결과: 4
	cout << sizeof(arr) << endl;	//결과: 12
	cout << arr << endl;		//결과: 주소값
	cout << ptr << endl;		//결과: arr 주소값과 동일
	cout << ptr[0] << endl;		//결과: 1
	cout << ptr[3] << endl;		//결과: 쓰레기값
```
- 배열의 원소를 생략하면 주소값(포인터)이 나온다. 
- 배열의 이름은 배열의 첫 번째 원소를 가르키는 상수 포인터 형식이다.
***
### 배열과 포인터 연산 +, -
```c++
	int arr[3] = { 1,2,3 };
	int* ptr = arr;

	cout << ptr + 1 << endl;	//결과: 원소 2 주소값
	cout << *(ptr + 1) << endl;	//결과: 2
	
	cout << arr + 1 << endl;	//결과: 원소 2 주소값
	cout << *(arr + 1) << endl;	//결과: 2
	
	for(i=0;i<3;i++)
	{
	*ptr++		//가능
	*(ptr + i)	//가능
	
	*arr++		//불가능 -> arr = arr + 1; arr는 배열이기 때문에, 주소값 자료형 할당은 불가능.
	*(arr + i)	//가능
	}
	

```
- 포인터 연산은 배열일 경우(연속된 메모리 공간)에만 사용한다.
- 현재 변수 타입의 크기만큼 더하거나 뺀다.
***
### 2차원 배열
```c++
```



