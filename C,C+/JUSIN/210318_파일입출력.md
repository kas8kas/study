```c++
#include <iostream>

using namespace std;
/*
	데이터 읽기쓰기에 따른 모드
	r - 데이터를 읽기위한 키워드 - 애는 파일이 없을경우. 통로개방 실패.
	w - 데이터를 쓰기위한 키워드 - 그냥 덮어쓰기. - 파일이 없을경우 생성.
	a - 덧붙여 쓸경우 사용하는 키워드

	데이터 종류에 따른 모드
	t - text모드 즉, 사람이 읽기 쉬운 텍스트로 저장이 되는 방식. - 잘 사용되진 않는다.
	b - 바이너리모드, 즉 사람이 읽기 어렵고 컴퓨터가 알기 쉬운 기계어로 저장이 되는 방식- 주로 바이너리 모드로 파일을 입출력한다. 사람이 읽기 힘들기 때문.
	*/
int main()
{
	FILE* fp = nullptr;
	int err = fopen_s(&fp, "../Data/NewData.txt", "wb");
	if (err == 0)
	{
		fputs("asd", fp);
		fclose(fp);
		fp = nullptr;
	}
	else
		cout << "통로 개방 실패... ㅠㅠ" << endl;


	FILE* fp1 = nullptr;
	errno_t  err = fopen_s(&fp1, "../Data/NewData.txt", "rb");
	char szBuf[256] = "";
	if (0 == err)
	{
		cout << "통로 개방 성공!" << endl;
		int ch = fgetc(fp1);
		fputc(ch, stdout);
		//-1 == 파일의 끝을 EOF 로 판별한다. 
		while (!feof(fp1))			//아... 문자열을 저장할때는 뒤에 널문자가 삽입되지 않는구나.. 

		{
			ch = fgetc(fp1);
			fputc(ch, stdout);
			//	fseek(fp, -5, SEEK_END);
			//	fwrite(iArr, sizeof(iArr), 1, fp);
			//	fread(iArr, sizeof(iArr), 1, fp);
		}
		fclose(fp1);
		fp1 = nullptr;
	}
	else
		cout << "통로 개방 실패... ㅠㅠ" << endl;
}
```
